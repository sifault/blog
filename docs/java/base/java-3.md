# final、finally和finalize的区别

## 一、性质不同

```
（1）final为关键字；
（2）finalize()为方法；
（3）finally为为区块标志，用于try语句中；
```

## 二、作用

（1）final为用于标识常量的关键字，final标识的关键字存储在常量池中（在这里final常量的具体用法将在下面进行介绍）；

（2）finalize()方法在Object中进行了定义，用于在对象“消失”时，由JVM进行调用用于对对象进行垃圾回收，类似于C++中的析构函数；用户自定义时，用于释放对象占用的资源（比如进行I/0操作）；

（3）finally{}用于标识代码块，与try{}进行配合，不论try中的代码执行完或没有执行完（这里指有异常），该代码块之中的程序必定会进行

## 三、final详解

**1、定义变量**

1.1 final定义基本类型变量时，要求变量初始化必须在声明时或者构造函数中，不能用于其它地方。该关键字定义的常量，除了初始化阶段，不能更改常量的值。

1.2 final定义对象的引用，该引用的初始化与定义常量时的要求一致；该关键字定义的对象内容可以改变，但是引用指向的地址不能改变；

**2、定义参数**

如果传入该参数定义的变量时，方法不能对该参数内容进行修改（错误），与定义变量的修改规则相同；java方法中传递基本类型时是传值的，java方法对于对象的传递是传参的；<归根结底，java中方法的传递是依靠传递“副本”：对于基本类型，首先建立一个Copy，并将传入的值赋值给Copy，然后对Copy进行操作；对于对象类型，首先建立一个引用Copy，并将传入的对象引用赋值给Copy>

比如：method（final int test）；

有些书上说，这里final定义参数，尤其是对象的参数很有作用，不能在方法内对于对象的内容进行改变，这样的说法是错误的！原来我也认为这样有些函数式编程的特点，不能对于对象的内容进行修改该，这里依旧可以对对象的内容进行修改。

String天生就是final类型的！

**3、定义方法**

（1）使用final关键字定义的方法，不能被子类继承；

（2）允许编译器将所有对此方法的调用转化为inline（行内）行为，即可以将此方法直接复制在调用处，而不是进行例行的方法调用（保存断点、压栈），这样会使程序的效率升高。但是---------如果过多的话，这样会造成代码膨胀，反而会影响效率，所以该方法要慎用。。

**4、定义类**

一个任何final类无法被任何人继承，这也就意味着此类在一个继承树中是一个叶子类，并且此类被认为是很完美的，不需要进行任何修改（总之是不推荐使用）

**final**

用于修饰类、成员变量和成员方法。final修饰的类，不能被继承（String、StrngBuilder、StringBuffer、Math，不可变类），其中所有的方法都不能被重写，所有不能同时用abstract和final修饰（abstract修饰的是抽象类，抽象类是用于被子类继承的，和final起相反的作用）；final修饰的方法不能被重写，但是子类可以用父类中final修饰的方法；final修饰的成员变量是不可变的，如果成员变量是基本数据类型，初始化之后成员变量的值不能被改变，如果成员变量是引用类型，那么它只能指向初始化时指向的那个对象，不能再指向别的对象，但是对象中的内容是允许改变的。

**finally**

finally是在异常处理时提供finally块来执行任何清除操作。不管有没有异常被抛出、捕获都会被执行。try块中的内容是在无异常时执行到结束。catch块中的内容，是在try块内容发生catch所声明的异常时，跳转到catch块中执行。finally块则是无论异常是否发生都会执行finally块的内容，所以在代码逻辑中有需要无论发生什么都必须执行的代码，可以放在finally块中。

**finalize**

finalize是方法名，java技术允许使用finalize（）方法在垃圾收集器将对象从内存中清楚出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的，它是在Object类中定义的，因此所有的类都继承了它。子类覆盖finalize（）方法以整理系统资源或者执行其他清理工作。finalize（）方法是在垃圾收集器删除对象之前对这个对象调用的。
